// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import "github.com/kazu/fbshelper/query/base"

// import (
// 	b "github.com/kazu/fbshelper/query/base"
// 	. "github.com/kazu/fbshelper/query/error"
// )

/*
must call 1 times per File ;
go run github . com / cheekybits / genny gen "File=Root False=false" ;
*/

type File struct {
	*base.CommonNode
}

func NewFile() *File {
	return &File{CommonNode: &base.CommonNode{}}
}

var File_IdxToType map[int]int = map[int]int{}
var File_IdxToTypeGroup map[int]int = map[int]int{}
var File_IdxToName map[int]string = map[int]string{}
var File_NameToIdx map[string]int = map[string]int{}

var DUMMP_FileFalse bool = base.SetNameIsStrunct("File", base.ToBool("False"))

func SetFileFields(nName, fName, fType string, fNum int) bool {
	enumFtype, ok := base.NameToType[fType]
	if ok {
		FileSetIdxToType(fNum, enumFtype)
	}
	//FIXME: 基本型以外は無視?

	FileSetIdxToName(fNum, fType)

	grp := FileGetTypeGroup(fType)
	FileSetTypeGroup(fNum, grp)

	File_IdxToName[fNum] = fType

	File_NameToIdx[fName] = fNum
	base.SetNameToIdx("File", File_NameToIdx)

	return true

}
func FileSetIdxToName(i int, s string) {
	File_IdxToName[i] = s

	base.SetIdxToName("File", File_IdxToName)
}

func FileSetIdxToType(k, v int) bool {
	File_IdxToType[k] = v
	base.SetIdxToType("File", File_IdxToType)
	return true
}

func FileSetTypeGroup(k, v int) bool {
	File_IdxToTypeGroup[k] = v
	base.SetdxToTypeGroup("File", File_IdxToTypeGroup)
	return true
}

func FileGetTypeGroup(s string) (result int) {
	return base.GetTypeGroup(s)
}

func (node File) commonNode() *base.CommonNode {
	if node.CommonNode == nil {
		base.Log(base.LOG_WARN, func() base.LogArgs {
			return base.F("CommonNode not found File")
		})
	} else if len(node.CommonNode.Name) == 0 || len(node.CommonNode.IdxToType) == 0 {
		node.CommonNode.Name = "File"
		node.CommonNode.IdxToType = File_IdxToType
		node.CommonNode.IdxToTypeGroup = File_IdxToTypeGroup
	}
	return node.CommonNode
}
func (node File) SearchInfo(pos int, fn base.RecFn, condFn base.CondFn) {

	node.commonNode().SearchInfo(pos, fn, condFn)
	// info := node.Info()
	// if condFn(pos, info) {
	// fn(base.NodePath{Name: "File", Idx: -1}, info)
	// }else{
	//     return
	// }

	// for i := 0; i < node.CountOfField(); i++ {
	// g := File_IdxToTypeGroup[i]
	//     if node.IsLeafAt(i) {
	//         fInfo := base.Info(node.ValueInfo(i))
	//         if condFn(pos, fInfo) {
	// fn(base.NodePath{Name: "File", Idx: i}, fInfo)
	//         }
	//         continue
	//     }
	// 	if base.IsMatchBit(g, base.FieldTypeStruct) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	//     } else if base.IsMatchBit(g, base.FieldTypeUnion) {
	// 		  mNode, _ := node.FieldAt(i).Member(int(node.FieldAt(i - 1).Byte())).(base.Noder)

	// 		  mNode.SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeSlice) && base.IsMatchBit(g, base.FieldTypeBasic1) {
	// 	} else if base.IsMatchBit(g, base.FieldTypeSlice) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeTable) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeBasic) {
	//     } else {
	// 		  base.Log(base.LOG_ERROR, func() base.LogArgs {
	//             return base.F("node must be Noder")
	//         })
	// 	}
	// }
}

// if base.FalseName["File"] {
// } else if base.IsFieldStruct(i) {
// } else if base.IsFieldUnion(i) {
// } else if base.IsFieldBytes(i) {
// } else if base.IsFieldSlice(i) {
// } else if base.IsFieldTable(i) {
// } else if base.IsFieldBasicType(i) {
// } else {
// 	base.Log(base.LOG_ERROR, func() base.LogArgs {
// return base.F("Invalid %s.%s idx=%d\n", "File", "FieldName", i)
// 	})
// }

func (node File) Info() (info base.Info) {

	return node.commonNode().Info()

	// if node.Node == nil {
	// 	node.Node = &base.Node{}
	// }

	// info.Pos = node.Pos
	// info.Size = -1
	// if base.FalseName["File"] {
	// 	size := 0
	// 	for i :=0; i < node.CountOfField(); i++ {
	// size += base.TypeToSize[File_IdxToType[i]]
	// 	}
	// 	info.Size = size
	// 	return info
	// }

	// for i := 0; i < len(node.VTable); i++ {
	//     vInfo := node.ValueInfo(i)
	//     if info.Pos + info.Size < vInfo.Pos + vInfo.Size {
	//         info.Size = (vInfo.Pos + vInfo.Size) - info.Pos
	//     }
	// }
	// return info

}

func (node File) IsLeafAt(j int) bool {

	return node.commonNode().IsLeafAt(j)

	// if base.IsFieldStruct(i) {

	// 	return false
	// } else if base.IsFieldUnion(i) {

	// 	return false
	// } else if base.IsFieldBytes(i) {

	// 	return true
	// } else if base.IsFieldSlice(i) {

	// 	return false
	// } else if base.IsFieldTable(i) {

	// 	return false
	// } else if base.IsFieldBasicType(i) {
	// 	return true
	// } else {
	// 	base.Log(base.LOG_ERROR, func() base.LogArgs {
	// return base.F("Invalid %s.%s idx=%d\n", "File", "FieldName", i)
	// 	})
	// }
	// return false
}

func (node File) CountOfField() int {
	return len(File_IdxToType)
}

func (node File) ValueInfo(i int) base.ValueInfo {
	return node.commonNode().ValueInfo(i)

	// if base.FalseName["File"] {
	// 	if len(node.ValueInfos) > i {
	// 		return node.ValueInfos[i]
	// 	}
	// 	node.ValueInfos = make([]base.ValueInfo, 0, node.CountOfField())
	// 	info := base.ValueInfo{Pos: node.Pos, Size: 0}
	// 	for i :=0; i < node.CountOfField(); i++ {
	// 		info.Pos += info.Size
	// info.Size = base.TypeToSize[File_IdxToType[i]]
	// 		node.ValueInfos = append(node.ValueInfos,  info)
	// 	}
	// }

	// grp := File_IdxToTypeGroup[i]

	// if base.IsFieldStruct(grp) {
	// 	if node.ValueInfos[i].IsNotReady() {
	// 			node.ValueInfoPos(i)
	// 	}

	// fTypeStr := File_IdxToName[j]
	// 	idxToType = All_IdxToType[fTypeStr]
	// 	size := 0
	// 	for nextIdx := 0 ; nextIdx < len(idxToType);  nextIdx++ {
	// 		size +=base.TypeToSize[idxToType[nextIdx]]
	// 	}
	// 	node.ValueInfos[i].Size = size

	// } else if base.IsFieldUnion(i) {

	// } else if base.IsFieldBytes(i) {
	// } else if base.IsFieldSlice(i) {
	// } else if base.IsFieldTable(i) {
	// } else if base.IsFieldBasicType(i) {
	// } else {
	// 		base.Log(base.LOG_ERROR, func() base.LogArgs {
	// return base.F("Invalid %s.%s idx=%d\n", "File", "FieldName", i)
	// 		})
	// }

	// return base.ValueInfo{}
}

func (node File) FieldAt(idx int) *base.CommonNode {
	//return node.commonNode().FieldAt(idx).NodeList
	return node.commonNode().FieldAt(idx)
}

// func (node File) SizeAsStruct() int {
// if base.FalseName["File"] {
// 		size := 0
// 		for i :=0; i < node.CountOfField(); i++ {
// size += base.TypeToSize[File_IdxToType[i]]
// 		}
// 		return size
// 	}
