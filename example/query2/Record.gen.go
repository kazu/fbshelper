// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import "github.com/kazu/fbshelper/query/base"

// import (
// 	b "github.com/kazu/fbshelper/query/base"
// 	. "github.com/kazu/fbshelper/query/error"
// )

/*
must call 1 times per Record ;
go run github . com / cheekybits / genny gen "Record=Root True=false" ;
*/

type Record struct {
	*base.CommonNode
}

func NewRecord() *Record {
	return &Record{CommonNode: &base.CommonNode{}}
}

var Record_IdxToType map[int]int = map[int]int{}
var Record_IdxToTypeGroup map[int]int = map[int]int{}
var Record_IdxToName map[int]string = map[int]string{}
var Record_NameToIdx map[string]int = map[string]int{}

var DUMMP_RecordTrue bool = base.SetNameIsStrunct("Record", base.ToBool("True"))

func SetRecordFields(nName, fName, fType string, fNum int) bool {
	enumFtype, ok := base.NameToType[fType]
	if ok {
		RecordSetIdxToType(fNum, enumFtype)
	}
	//FIXME: 基本型以外は無視?

	RecordSetIdxToName(fNum, fType)

	grp := RecordGetTypeGroup(fType)
	RecordSetTypeGroup(fNum, grp)

	Record_IdxToName[fNum] = fType

	Record_NameToIdx[fName] = fNum
	base.SetNameToIdx("Record", Record_NameToIdx)

	return true

}
func RecordSetIdxToName(i int, s string) {
	Record_IdxToName[i] = s

	base.SetIdxToName("Record", Record_IdxToName)
}

func RecordSetIdxToType(k, v int) bool {
	Record_IdxToType[k] = v
	base.SetIdxToType("Record", Record_IdxToType)
	return true
}

func RecordSetTypeGroup(k, v int) bool {
	Record_IdxToTypeGroup[k] = v
	base.SetdxToTypeGroup("Record", Record_IdxToTypeGroup)
	return true
}

func RecordGetTypeGroup(s string) (result int) {
	return base.GetTypeGroup(s)
}

func (node Record) commonNode() *base.CommonNode {
	if node.CommonNode == nil {
		base.Log(base.LOG_WARN, func() base.LogArgs {
			return base.F("CommonNode not found Record")
		})
	} else if len(node.CommonNode.Name) == 0 || len(node.CommonNode.IdxToType) == 0 {
		node.CommonNode.Name = "Record"
		node.CommonNode.IdxToType = Record_IdxToType
		node.CommonNode.IdxToTypeGroup = Record_IdxToTypeGroup
	}
	return node.CommonNode
}
func (node Record) SearchInfo(pos int, fn base.RecFn, condFn base.CondFn) {

	node.commonNode().SearchInfo(pos, fn, condFn)
	// info := node.Info()
	// if condFn(pos, info) {
	// fn(base.NodePath{Name: "Record", Idx: -1}, info)
	// }else{
	//     return
	// }

	// for i := 0; i < node.CountOfField(); i++ {
	// g := Record_IdxToTypeGroup[i]
	//     if node.IsLeafAt(i) {
	//         fInfo := base.Info(node.ValueInfo(i))
	//         if condFn(pos, fInfo) {
	// fn(base.NodePath{Name: "Record", Idx: i}, fInfo)
	//         }
	//         continue
	//     }
	// 	if base.IsMatchBit(g, base.FieldTypeStruct) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	//     } else if base.IsMatchBit(g, base.FieldTypeUnion) {
	// 		  mNode, _ := node.FieldAt(i).Member(int(node.FieldAt(i - 1).Byte())).(base.Noder)

	// 		  mNode.SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeSlice) && base.IsMatchBit(g, base.FieldTypeBasic1) {
	// 	} else if base.IsMatchBit(g, base.FieldTypeSlice) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeTable) {
	// 		  node.FieldAt(i).SearchInfo(pos, fn, condFn)
	// 	} else if base.IsMatchBit(g, base.FieldTypeBasic) {
	//     } else {
	// 		  base.Log(base.LOG_ERROR, func() base.LogArgs {
	//             return base.F("node must be Noder")
	//         })
	// 	}
	// }
}

// if base.TrueName["Record"] {
// } else if base.IsFieldStruct(i) {
// } else if base.IsFieldUnion(i) {
// } else if base.IsFieldBytes(i) {
// } else if base.IsFieldSlice(i) {
// } else if base.IsFieldTable(i) {
// } else if base.IsFieldBasicType(i) {
// } else {
// 	base.Log(base.LOG_ERROR, func() base.LogArgs {
// return base.F("Invalid %s.%s idx=%d\n", "Record", "FieldName", i)
// 	})
// }

func (node Record) Info() (info base.Info) {

	return node.commonNode().Info()

	// if node.Node == nil {
	// 	node.Node = &base.Node{}
	// }

	// info.Pos = node.Pos
	// info.Size = -1
	// if base.TrueName["Record"] {
	// 	size := 0
	// 	for i :=0; i < node.CountOfField(); i++ {
	// size += base.TypeToSize[Record_IdxToType[i]]
	// 	}
	// 	info.Size = size
	// 	return info
	// }

	// for i := 0; i < len(node.VTable); i++ {
	//     vInfo := node.ValueInfo(i)
	//     if info.Pos + info.Size < vInfo.Pos + vInfo.Size {
	//         info.Size = (vInfo.Pos + vInfo.Size) - info.Pos
	//     }
	// }
	// return info

}

func (node Record) IsLeafAt(j int) bool {

	return node.commonNode().IsLeafAt(j)

	// if base.IsFieldStruct(i) {

	// 	return false
	// } else if base.IsFieldUnion(i) {

	// 	return false
	// } else if base.IsFieldBytes(i) {

	// 	return true
	// } else if base.IsFieldSlice(i) {

	// 	return false
	// } else if base.IsFieldTable(i) {

	// 	return false
	// } else if base.IsFieldBasicType(i) {
	// 	return true
	// } else {
	// 	base.Log(base.LOG_ERROR, func() base.LogArgs {
	// return base.F("Invalid %s.%s idx=%d\n", "Record", "FieldName", i)
	// 	})
	// }
	// return false
}

func (node Record) CountOfField() int {
	return len(Record_IdxToType)
}

func (node Record) ValueInfo(i int) base.ValueInfo {
	return node.commonNode().ValueInfo(i)

	// if base.TrueName["Record"] {
	// 	if len(node.ValueInfos) > i {
	// 		return node.ValueInfos[i]
	// 	}
	// 	node.ValueInfos = make([]base.ValueInfo, 0, node.CountOfField())
	// 	info := base.ValueInfo{Pos: node.Pos, Size: 0}
	// 	for i :=0; i < node.CountOfField(); i++ {
	// 		info.Pos += info.Size
	// info.Size = base.TypeToSize[Record_IdxToType[i]]
	// 		node.ValueInfos = append(node.ValueInfos,  info)
	// 	}
	// }

	// grp := Record_IdxToTypeGroup[i]

	// if base.IsFieldStruct(grp) {
	// 	if node.ValueInfos[i].IsNotReady() {
	// 			node.ValueInfoPos(i)
	// 	}

	// fTypeStr := Record_IdxToName[j]
	// 	idxToType = All_IdxToType[fTypeStr]
	// 	size := 0
	// 	for nextIdx := 0 ; nextIdx < len(idxToType);  nextIdx++ {
	// 		size +=base.TypeToSize[idxToType[nextIdx]]
	// 	}
	// 	node.ValueInfos[i].Size = size

	// } else if base.IsFieldUnion(i) {

	// } else if base.IsFieldBytes(i) {
	// } else if base.IsFieldSlice(i) {
	// } else if base.IsFieldTable(i) {
	// } else if base.IsFieldBasicType(i) {
	// } else {
	// 		base.Log(base.LOG_ERROR, func() base.LogArgs {
	// return base.F("Invalid %s.%s idx=%d\n", "Record", "FieldName", i)
	// 		})
	// }

	// return base.ValueInfo{}
}

func (node Record) FieldAt(idx int) *base.CommonNode {
	//return node.commonNode().FieldAt(idx).NodeList
	return node.commonNode().FieldAt(idx)
}

// func (node Record) SizeAsStruct() int {
// if base.TrueName["Record"] {
// 		size := 0
// 		for i :=0; i < node.CountOfField(); i++ {
// size += base.TypeToSize[Record_IdxToType[i]]
// 		}
// 		return size
// 	}
