// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import "github.com/kazu/fbshelper/query/base"

/*
must call 1 times per Table / struct ( NumList ) ;
*/

type NumList struct {
	*base.CommonNode
}

func NewNumList() *NumList {
	return &NumList{CommonNode: &base.CommonNode{}}
}

var NumList_IdxToType map[int]int = map[int]int{}
var NumList_IdxToTypeGroup map[int]int = map[int]int{}
var NumList_IdxToName map[int]string = map[int]string{}
var NumList_NameToIdx map[string]int = map[string]int{}

var DUMMP_NumListFalse bool = base.SetNameIsStrunct("NumList", base.ToBool("False"))

func SetNumListFields(nName, fName, fType string, fNum int) bool {

	base.RequestSettingNameFields(nName, fName, fType, fNum)

	enumFtype, ok := base.NameToType[fType]
	if ok {
		NumListSetIdxToType(fNum, enumFtype)
	}
	//FIXME: basic type only store?

	NumListSetIdxToName(fNum, fType)

	grp := NumListGetTypeGroup(fType)
	NumListSetTypeGroup(fNum, grp)

	NumList_IdxToName[fNum] = fType

	NumList_NameToIdx[fName] = fNum
	base.SetNameToIdx("NumList", NumList_NameToIdx)

	return true

}
func NumListSetIdxToName(i int, s string) {
	NumList_IdxToName[i] = s

	base.SetIdxToName("NumList", NumList_IdxToName)
}

func NumListSetIdxToType(k, v int) bool {
	NumList_IdxToType[k] = v
	base.SetIdxToType("NumList", NumList_IdxToType)
	return true
}

func NumListSetTypeGroup(k, v int) bool {
	NumList_IdxToTypeGroup[k] = v
	base.SetdxToTypeGroup("NumList", NumList_IdxToTypeGroup)
	return true
}

func NumListGetTypeGroup(s string) (result int) {
	return base.GetTypeGroup(s)
}

func (node NumList) commonNode() *base.CommonNode {
	if node.CommonNode == nil {
		base.Log(base.LOG_WARN, func() base.LogArgs {
			return base.F("CommonNode not found NumList")
		})
	} else if len(node.CommonNode.Name) == 0 || len(node.CommonNode.IdxToType) == 0 {
		node.CommonNode.Name = "NumList"
		node.CommonNode.IdxToType = NumList_IdxToType
		node.CommonNode.IdxToTypeGroup = NumList_IdxToTypeGroup
	}
	return node.CommonNode
}
func (node NumList) SearchInfo(pos int, fn base.RecFn, condFn base.CondFn) {

	node.commonNode().SearchInfo(pos, fn, condFn)

}

func (node NumList) Info() (info base.Info) {

	return node.commonNode().Info()

}

func (node NumList) IsLeafAt(j int) bool {

	return node.commonNode().IsLeafAt(j)

}

func (node NumList) CountOfField() int {
	return len(NumList_IdxToType)
}

func (node NumList) ValueInfo(i int) base.ValueInfo {
	return node.commonNode().ValueInfo(i)
}

func (node NumList) FieldAt(idx int) *base.CommonNode {
	return node.commonNode().FieldAt(idx)
}

func (node NumList) Root() Root {
	return toRoot(node.Base)
}

type NumListWithErr struct {
	*NumList
	Err error
}

func NumListSingle(node *NumList, e error) NumListWithErr {
	return NumListWithErr{NumList: node, Err: e}
}
