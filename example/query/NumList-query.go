
// Code generated by genmaps.go; DO NOT EDIT.
// template file is https://github.com/kazu/fbshelper/blob/master/template/query.go.tmpl github.com/kazu/fbshelper/template/query.go.tmpl 
//   https://github.com/kazu/fbshelper/blob/master/template/union.query.go.tmpl


package vfs_schema

import (
    flatbuffers "github.com/google/flatbuffers/go"
    base "github.com/kazu/fbshelper/query/base"
    "reflect"
)

const (
    DUMMY_NumList = flatbuffers.VtableMetadataFields
)

const (
        NumList_Num =     0
)

var NumList_FieldEnum = map[string]int{
        "Num": NumList_Num,
}



type FbsNumList struct {
	*base.Node
}


type FbsNumListNum struct {
    *base.NodeList
}

func (node FbsNumList) SearchInfo(pos int, fn RecFn, condFn CondFn) {

	info := node.Info()

	if condFn(pos, info) {
		fn(base.NodePath{Name: "NumList", Idx: -1}, info)
	}else{
        return
    }

	for i := 0; i < node.CountOfField(); i++ {
		if node.IsLeafAt(i) {
			fInfo := base.Info(node.ValueInfo(i))
			if condFn(pos, fInfo) {
				fn(base.NodePath{Name: "NumList", Idx: i}, fInfo)
			}
			continue
		}
        switch i {
        case 0:
                node.Num().SearchInfo(pos, fn, condFn)    
        default:
			base.Log(base.LOG_ERROR, func() base.LogArgs {
				return F("node must be Noder")
			})
        }

	}

}
func (node FbsNumList) Info() base.Info {

    info := base.Info{Pos: node.Pos, Size: -1}
    for i := 0; i < len(node.VTable); i++ {
        vInfo := node.ValueInfo(i)
        if info.Pos + info.Size < vInfo.Pos + vInfo.Size {
            info.Size = (vInfo.Pos + vInfo.Size) - info.Pos
        }
    }
    return info    
}


func (node FbsNumList) IsLeafAt(i int) bool {
    switch i {
    case 0:
        return false
    }
    return false
}
func (node FbsNumList) ValueInfo(i int) base.ValueInfo {

    switch i {
    case 0:
         if node.ValueInfos[i].IsNotReady() {
            node.ValueInfoPosList(i)
        }
        node.ValueInfos[i].Size = node.Num().Info().Size
     }
     return node.ValueInfos[i]
}


func (node FbsNumList) FieldAt(i int) interface{} {

    switch i {
    case 0:
        return node.Num()
     }
     return nil
}


// Unmarsla parse flatbuffers data and store the result
// in the value point to by v, if v is ni or not pointer,
// Unmarshal returns an ERR_MUST_POINTER, ERR_INVALID_TYPE
func (node FbsNumList) Unmarshal(v interface{}) error {

    return node.Node.Unmarshal(v, func(s string, rv reflect.Value) error {
        
        switch NumList_FieldEnum[s] {
        }
        return nil
    })

}




func (node FbsNumList) Num() FbsNumListNum {
    if node.VTable[0] == 0 {
        return FbsNumListNum{}
    }
    nodelist :=  node.ValueList(0)
    return FbsNumListNum{
                NodeList: &nodelist,
    }
}



// CountOfField ... returns count of table/struct fields
func (node FbsNumList) CountOfField() int {
    return 1
}

// SetNum ... store v value to {$v.Name}} field.
func (node FbsNumList) SetNum(v  FbsNumListNum ) error {    
        return base.ERR_NO_SUPPORT    
}



        
        
             
               

func (node FbsNumListNum) At(i int) int32 {
    if i >= int(node.ValueInfo.VLen) || i < 0 {    
		return int32(0)    
	}

    ptr := int(node.ValueInfo.Pos) + i*4
    return int32(flatbuffers.GetInt32( node.R(ptr) ))
}


func (node FbsNumListNum) First() int32 {
	return node.At(0)
}


func (node FbsNumListNum) Last() int32 {
	return node.At(int(node.ValueInfo.VLen)-1)
}

func (node FbsNumListNum) Select(fn func(m int32) bool) []int32 {

	result := make([]int32, 0, int(node.ValueInfo.VLen))
	for i := 0; i < int(node.ValueInfo.VLen); i++ {
		if m := node.At(i); fn(m) {
			result = append(result, m)
		}
	}
	return result
}

func (node FbsNumListNum) Find(fn func(m int32) bool) int32{

	for i := 0; i < int(node.ValueInfo.VLen); i++ {
		if m := node.At(i); fn(m) {
			return m
		}
	}    
	return int32(0)   

}

func (node FbsNumListNum) All() []int32 {
	return node.Select(func(m int32) bool { return true })
}

func (node FbsNumListNum) Count() int {
	return int(node.ValueInfo.VLen)
}

func (node FbsNumListNum) Info() base.Info {

    info := base.Info{Pos: node.ValueInfo.Pos, Size: -1}   
    ptr := int(node.ValueInfo.Pos) + (int(node.ValueInfo.VLen)-1)*4 
    vInfo := base.Info{Pos: ptr, Size: base.SizeOfint32}



    if info.Pos + info.Size < vInfo.Pos + vInfo.Size {
        info.Size = (vInfo.Pos + vInfo.Size) - info.Pos
    }
    return info
}

func (node FbsNumListNum) SearchInfo(pos int, fn RecFn, condFn CondFn) {

    info := node.Info()

    if condFn(pos, info) {
        fn(base.NodePath{Name: "NumList.Num", Idx: -1}, info)
	}else{
        return
    }

    var v interface{}
    for _, cNode := range node.All() {
        v = cNode
        if vv, ok := v.(Searcher); ok {    
                vv.SearchInfo(pos, fn, condFn)
        }else{
            goto NO_NODE
        }
    }
    return
    

NO_NODE:     
    for i := 0 ; i < int(node.ValueInfo.VLen) ; i++ {
        ptr := int(node.ValueInfo.Pos) + i*4
        start := ptr + int(flatbuffers.GetUint32( node.R(ptr) ))
        size := info.Size
        if i + 1 < int(node.ValueInfo.Pos) {
            size = ptr+4 + int(flatbuffers.GetUint32( node.R(ptr+4) )) - start
        }
        cInfo := base.Info{Pos: start, Size: size}
        if condFn(pos, info) {
            fn(base.NodePath{Name: "NumList.Num", Idx: i}, cInfo)
        }
    }
}
