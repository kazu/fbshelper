
// Code generated by genmaps.go; DO NOT EDIT.
// template file is https://github.com/kazu/fbshelper/blob/master/template/query.go.tmpl github.com/kazu/fbshelper/template/query.go.tmpl 
//   https://github.com/kazu/fbshelper/blob/master/template/union.query.go.tmpl


package vfs_schema

import (
    flatbuffers "github.com/google/flatbuffers/go"
    base "github.com/kazu/fbshelper/query/base"
    "reflect"
)

const (
    DUMMY_File = flatbuffers.VtableMetadataFields
)

const (
        File_Id =     0
        File_Name =     1
        File_IndexAt =     2
)

var File_FieldEnum = map[string]int{
        "Id": File_Id,
        "Name": File_Name,
        "IndexAt": File_IndexAt,
}



type FbsFile struct {
	*base.Node
}



func (node FbsFile) SearchInfo(pos int, fn RecFn, condFn CondFn) {

	info := node.Info()

    /* if info.Pos > pos {
        return
    }*/

	if condFn(pos, info) {
		fn(base.NodePath{Name: "File", Idx: -1}, info)
	}else{
        return
    }

	for i := 0; i < node.CountOfField(); i++ {
		if node.IsLeafAt(i) {
			fInfo := base.Info(node.ValueInfo(i))
			if condFn(pos, fInfo) {
				fn(base.NodePath{Name: "File", Idx: i}, info)
			}
			continue
		}
        switch i {
        case 0:
        case 1:
        case 2:    
        default:
			base.Log(base.LOG_ERROR, func() base.LogArgs {
				return F("node must be Noder")
			})
        }

	}

}
func (node FbsFile) Info() base.Info {

    info := base.Info{Pos: node.Pos, Size: -1}
    for i := 0; i < len(node.VTable); i++ {
        vInfo := node.ValueInfo(i)
        if info.Pos + info.Size < vInfo.Pos + vInfo.Size {
            info.Size = (vInfo.Pos + vInfo.Size) - info.Pos
        }
    }
    return info    
}


func (node FbsFile) IsLeafAt(i int) bool {
    switch i {
    case 0:
        return true
    case 1:
        return true
    case 2:
        return true
    }
    return false
}
func (node FbsFile) ValueInfo(i int) base.ValueInfo {

    switch i {
    case 0:
        if node.ValueInfos[i].IsNotReady() {
            node.ValueInfoPos(i)
        }
        node.ValueInfos[i].Size = base.SizeOfuint64
    case 1:
        if node.ValueInfos[i].IsNotReady() {
            node.ValueInfoPosBytes(i)
        }
    case 2:
        if node.ValueInfos[i].IsNotReady() {
            node.ValueInfoPos(i)
        }
        node.ValueInfos[i].Size = base.SizeOfint64
     }
     return node.ValueInfos[i]
}


func (node FbsFile) FieldAt(i int) interface{} {

    switch i {
    case 0:
        return node.Id()
    case 1:
        return node.Name()
    case 2:
        return node.IndexAt()
     }
     return nil
}


// Unmarsla parse flatbuffers data and store the result
// in the value point to by v, if v is ni or not pointer,
// Unmarshal returns an ERR_MUST_POINTER, ERR_INVALID_TYPE
func (node FbsFile) Unmarshal(v interface{}) error {

    return node.Node.Unmarshal(v, func(s string, rv reflect.Value) error {
        
        switch File_FieldEnum[s] {
        case File_Id:
            //return node.Id()
            rv.Set(reflect.ValueOf(  node.Id() ))
        case File_Name:
            //return node.Name()
            rv.Set(reflect.ValueOf(  node.Name() ))
        case File_IndexAt:
            //return node.IndexAt()
            rv.Set(reflect.ValueOf(  node.IndexAt() ))
        }
        return nil
    })

}




func (node FbsFile) Id() uint64 {
    if node.VTable[0] == 0 {
        return uint64(0)
    }
    return uint64(flatbuffers.GetUint64(node.ValueNormal(0)))
}


func (node FbsFile) Name() []byte {
    if node.VTable[1] == 0 {
        return nil
    }
    return node.ValueBytes(1)
}


func (node FbsFile) IndexAt() int64 {
    if node.VTable[2] == 0 {
        return int64(0)
    }
    return int64(flatbuffers.GetInt64(node.ValueNormal(2)))
}




func (node FbsFile) CountOfField() int {
    return 3
}
